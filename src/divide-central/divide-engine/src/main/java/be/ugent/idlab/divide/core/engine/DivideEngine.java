package be.ugent.idlab.divide.core.engine;

import be.ugent.idlab.divide.core.component.IComponent;
import be.ugent.idlab.divide.core.context.Context;
import be.ugent.idlab.divide.core.context.ContextEnrichment;
import be.ugent.idlab.divide.core.exception.DivideInitializationException;
import be.ugent.idlab.divide.core.exception.DivideInvalidInputException;
import be.ugent.idlab.divide.core.exception.DivideNotInitializedException;
import be.ugent.idlab.divide.core.exception.DivideQueryDeriverException;
import be.ugent.idlab.divide.core.query.DivideQueryFactory;
import be.ugent.idlab.divide.core.query.IDivideQuery;
import be.ugent.idlab.divide.core.query.parser.DivideQueryParserFactory;
import be.ugent.idlab.divide.core.query.parser.IDivideQueryParser;
import be.ugent.idlab.divide.core.query.parser.InvalidDivideQueryParserInputException;
import be.ugent.idlab.divide.rsp.RspQueryLanguage;
import be.ugent.idlab.divide.util.LogConstants;
import be.ugent.idlab.kb.IKnowledgeBase;
import be.ugent.idlab.kb.exception.KnowledgeBaseOperationException;
import be.ugent.idlab.util.rdf.jena3.owlapi4.JenaOwlApiUtilities;
import be.ugent.idlab.util.rdf.jena3.owlapi4.JenaRuleUtilities;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.reasoner.rulesys.Rule;
import org.semanticweb.owlapi.model.OWLOntology;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

class DivideEngine implements IDivideEngine {

    private static final Logger LOGGER = LoggerFactory.getLogger(DivideEngine.class.getName());

    /**
     * Worker thread pool of maximum 100 threads to parallelize
     * the query derivation process
     */
    private final ThreadPoolExecutor workerThreadPool;

    /**
     * Instance responsible for deriving the instantiated RSP-QL queries from
     * the generic DIVIDE queries
     */
    private IDivideQueryDeriver divideQueryDeriver;

    /**
     * Manager of the DIVIDE components associated to this DIVIDE engine
     */
    private DivideComponentManager divideComponentManager;

    /**
     * Map linking a query name to the DIVIDE query instance
     */
    private final Map<String, IDivideQuery> divideQueryMap;

    /**
     * Map linking a component ID to its queue where query update
     * requests can be put
     */
    private final Map<String, LinkedBlockingQueue<IDivideQueryUpdateTask>> componentQueryUpdateQueueMap;

    /**
     * Map linking a component ID to the thread that is processing
     * its query update queue
     */
    private final Map<String, Thread> componentQueryUpdateThreadMap;

    private DivideOntology divideOntology;

    /**
     * Boolean representing whether the engine has been successfully initialized
     */
    private boolean initialized;

    /**
     * Boolean representing whether RSP engine streams on a component should be
     * paused when context changes are detected that trigger the DIVIDE query
     * derivation for that component
     */
    private boolean pauseRspEngineStreamsOnContextChanges;

    /**
     * Boolean representing whether variable matches in the input for the DIVIDE
     * query parser that are not defined as mappings, should be considered as
     * mappings by default
     */
    private boolean processUnmappedVariableMatchesInParser;

    /**
     * Boolean representing whether variables in the RSP-QL query body generated by
     * the DIVIDE query parser, should be validated (= checked for occurrence in the
     * WHERE clause of the query or in the set of input variables that will be
     * substituted during the DIVIDE query derivation) during parsing
     */
    private boolean validateUnboundVariablesInRspQlQueryBodyInParser;

    /**
     * Patterns used for preprocessing a DIVIDE query's sensor query rule
     */
    private static final Pattern INPUT_VARIABLE_NAME_PATTERN =
            Pattern.compile("\"\\?([^\"]+)\"");
    private static final Pattern INPUT_VARIABLE_DEFINITION_PATTERN =
            Pattern.compile("\\(" + INPUT_VARIABLE_NAME_PATTERN + "\\s+\\?[^()]+\\s*\\)");
    private static final Pattern INPUT_VARIABLE_LIST_PATTERN =
            Pattern.compile("(inputVariables>?)\\s+\\(\\s*(\\s*" +
                    INPUT_VARIABLE_DEFINITION_PATTERN + ")*\\s*\\)");

    DivideEngine() {
        // set initialized flag to false until initialize method is called
        // and successfully ended
        this.initialized = false;

        // create engine objects
        this.divideQueryDeriver = null;
        this.divideComponentManager = null;
        this.divideQueryMap = new HashMap<>();
        this.componentQueryUpdateQueueMap = new HashMap<>();
        this.componentQueryUpdateThreadMap = new HashMap<>();
        this.divideOntology = null;

        // create worker thread pool
        this.workerThreadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(100);
        this.workerThreadPool.setCorePoolSize(50);
        this.workerThreadPool.setMaximumPoolSize(100);
        // alive time set below has no influence on whether and when the query update
        // threads for the different components are stopped, since they are running
        // outside this worker thread pool (it is only used for the query derivation for
        // a single DIVIDE query, submitted by the query update thread!)
        this.workerThreadPool.setKeepAliveTime(1, TimeUnit.HOURS);
    }

    @Override
    public void initialize(IDivideQueryDeriver divideQueryDeriver,
                           IKnowledgeBase<Model> knowledgeBase,
                           Model divideOntologyModel,
                           boolean pauseRspEngineStreamsOnContextChanges,
                           boolean processUnmappedVariableMatchesInParser,
                           boolean validateUnboundVariablesInRspQlQueryBodyInParser)
            throws DivideInvalidInputException, DivideInitializationException {
        LOGGER.info("Initializing DIVIDE engine...");

        // save engine that handles the actual query derivation
        this.divideQueryDeriver = divideQueryDeriver;

        // load ontology in DIVIDE query deriver
        loadOntology(divideOntologyModel);

        // register ontology as TBox of the knowledge base
        // (important to do this before creating the DIVIDE component manager,
        //  since this manager will register itself as an observer of the
        //  ontology, and should not receive a TBox update yet
        try {
            LOGGER.info("Registering DIVIDE ontology as TBox of knowledge base");
            knowledgeBase.setTBox(divideOntologyModel);
        } catch (KnowledgeBaseOperationException e) {
            // should normally not occur
            throw new DivideInitializationException(
                    "Error when registering DIVIDE ontology as TBox in knowledge base", e);
        }

        // save setting on pausing RSP engine streams
        this.pauseRspEngineStreamsOnContextChanges = pauseRspEngineStreamsOnContextChanges;

        // save parser settings
        this.processUnmappedVariableMatchesInParser = processUnmappedVariableMatchesInParser;
        this.validateUnboundVariablesInRspQlQueryBodyInParser =
                validateUnboundVariablesInRspQlQueryBodyInParser;

        // create DIVIDE component manager
        this.divideComponentManager = new DivideComponentManager(
                this, knowledgeBase, pauseRspEngineStreamsOnContextChanges);

        // register successful initialization
        this.initialized = true;
    }

    /**
     * Loads the ontology that needs to be used as input (TBox) for each query
     * derivation performed by the query deriver of this engine.
     *
     * If an ontology has been loaded successfully in the past at least once,
     * this method will reload the ontology based on the new input. If something
     * goes wrong during this reloading and an exception is thrown, the query
     * deriver should still be in a valid state and continue working with the
     * latest successfully loaded ontology.
     *
     * @throws DivideInitializationException if something goes wrong during the ontology
     *                                       loading process, which prevents the DIVIDE engine
     *                                       from functioning as it should
     * @throws DivideInvalidInputException when the specified ontology contains invalid
     *                                     statements, i.e., statements which cannot be loaded
     *                                     by the query deriver
     */
    synchronized void loadOntology(Model divideOntologyModel)
            throws DivideInvalidInputException, DivideInitializationException {
        LOGGER.info("Loading ontology...");
        LOGGER.debug(LogConstants.METRIC_MARKER, "LOAD_ONTOLOGY_START");

        long start = System.currentTimeMillis();

        // load ontology into DIVIDE query deriver
        divideQueryDeriver.loadOntology(divideOntologyModel);

        // convert ontology to a set of rules
        // (to be used by the context enrichers)
        OWLOntology divideOntology =
                JenaOwlApiUtilities.getOWLOntology(divideOntologyModel);
        List<Rule> divideOntologyRules =
                JenaRuleUtilities.convertOntologyToRulesList(divideOntology);

        // save ontology model and rules to engine
        this.divideOntology = new DivideOntology(divideOntologyModel, divideOntologyRules);

        // update context enrichers for all components registered to engine
        if (divideComponentManager != null) {
            for (IComponent component : divideComponentManager.getRegisteredComponents()) {
                enqueueContextEnricherUpdaterTask(component);
            }
        }

        LOGGER.debug(LogConstants.METRIC_MARKER, "LOAD_ONTOLOGY_END");
        LOGGER.info("Finished loading ontology in {} ms", System.currentTimeMillis() - start);
    }

    @Override
    public IDivideQuery addDivideQuery(String name,
                                       String queryPattern,
                                       String sensorQueryRule,
                                       String goal,
                                       ContextEnrichment contextEnrichment) throws
            DivideNotInitializedException, DivideQueryDeriverException, DivideInvalidInputException {
        LOGGER.info("Adding DIVIDE query with name '{}'...", name);

        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        // ensure DIVIDE query with that name does not yet exist
        if (divideQueryMap.containsKey(name)) {
            LOGGER.warn("Trying to add DIVIDE query with already existing name '{}'", name);
            return null;
        }

        // preprocess sensor query rule to avoid issues with overlapping variables
        sensorQueryRule = preprocessSensorQueryRule(sensorQueryRule);

        // create DIVIDE query
        IDivideQuery divideQuery = DivideQueryFactory.createInstance(
                name, queryPattern, sensorQueryRule, goal, contextEnrichment);

        try {
            // validate the defined context enrichment of the new DIVIDE query
            validateContextEnrichment(divideQuery.getContextEnrichment());

            // register DIVIDE query at query deriver
            divideQueryDeriver.registerQuery(divideQuery, getQueryParser());

            // keep track of DIVIDE query in map
            synchronized (divideQueryMap) {
                divideQueryMap.put(name, divideQuery);
            }

            // start query derivation for this DIVIDE query only,
            // for each component registered to the engine
            for (IComponent component : divideComponentManager.getRegisteredComponents()) {
                // to do so, first a context enricher should be created for this new query
                // -> enqueue task to register new context enricher
                enqueueContextEnricherUpdaterTask(component, divideQuery);

                // retrieve current context associated to component
                Model componentContext = divideComponentManager.
                        getContextAssociatedToComponent(component.getId());

                // enqueue query derivation for new DIVIDE query if context of component
                // exists and is non-empty
                if (componentContext == null) {
                    LOGGER.info("No context available yet for component '{}' " +
                            "=> no query derivation for new DIVIDE query '{}' enqueued",
                            component.getId(), divideQuery.getName());
                } else if (componentContext.isEmpty()) {
                    LOGGER.info("Available context for component '{}' is empty " +
                            "=> no query derivation for new DIVIDE query '{}' enqueued",
                            component.getId(), divideQuery.getName());
                } else {
                    LOGGER.info("Context for component '{}' is available and non-empty " +
                            "=> query derivation for new DIVIDE query '{}' enqueued",
                            component.getId(), divideQuery.getName());
                    enqueueSpecificDivideQueryDerivationTask(
                            component, new Context(componentContext), divideQuery);
                }
            }

            return divideQuery;

        } catch (DivideInvalidInputException e) {
            LOGGER.warn("Something went wrong when registering the new DIVIDE query to " +
                    "because the given input is invalid", e);
            throw e;

        } catch (DivideQueryDeriverException e) {
            LOGGER.warn("Something went wrong when registering the new DIVIDE query to " +
                    "the query deriver - DIVIDE query is therefore NOT registered", e);
            throw e;
        }
    }

    private void validateContextEnrichment(ContextEnrichment contextEnrichment)
            throws DivideInvalidInputException {
        // validate every individual query
        try {
            getQueryParser().validateDivideQueryContextEnrichment(contextEnrichment);
        } catch (InvalidDivideQueryParserInputException e) {
            throw new DivideInvalidInputException(
                    "DIVIDE query contains invalid context-enriching queries" +
                            (e.getMessage() != null ? ": " + e.getMessage() : ""), e);
        }
    }

    @Override
    public void removeDivideQuery(String name,
                                  boolean unregisterQueries) throws DivideNotInitializedException {
        LOGGER.info("Removing DIVIDE query with name '{}'...", name);

        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        IDivideQuery divideQuery;
        synchronized (divideQueryMap) {
            divideQuery = divideQueryMap.remove(name);
        }
        if (divideQuery != null) {
            // unregister query at query deriver
            divideQueryDeriver.unregisterQuery(divideQuery);

            // enqueue task to handle the removal of the DIVIDE query at this component
            // -> context enricher for this query will be unregistered
            // -> all RSP queries that originate from this DIVIDE query are unregistered
            //    on the registered components of the system (only if specified to do so)
            for (IComponent component : divideComponentManager.getRegisteredComponents()) {
                enqueueDivideQueryRemovalHandlingTask(component, divideQuery, unregisterQueries);
            }
        }
    }

    @Override
    public Collection<IDivideQuery> getDivideQueries() throws DivideNotInitializedException {
        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        return divideQueryMap.values();
    }

    @Override
    public IDivideQuery getDivideQueryByName(String name) throws DivideNotInitializedException {
        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        return divideQueryMap.get(name);
    }

    @Override
    public IComponent registerComponent(List<String> contextIris,
                                        RspQueryLanguage rspQueryLanguage,
                                        String rspEngineUrl)
            throws DivideNotInitializedException, DivideInvalidInputException {
        LOGGER.info("Adding new DIVIDE component...");

        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        // register new component at component manager
        IComponent component = divideComponentManager.registerComponent(
                contextIris, rspQueryLanguage, rspEngineUrl);

        // if component is not zero, prepare the engine for handling query update requests
        if (component != null) {
            // create a queue for this component where query updates requests can be put
            final LinkedBlockingQueue<IDivideQueryUpdateTask> queryUpdateQueue =
                    new LinkedBlockingQueue<>();
            componentQueryUpdateQueueMap.put(component.getId(), queryUpdateQueue);

            // create and start a thread for this component that continuously processes
            // the query update queue
            LOGGER.info("Starting new query update thread for component '{}'", component.getId());
            Thread queryUpdateThread = new Thread(() ->
                    processRspQueryUpdateQueue(component, queryUpdateQueue));
            queryUpdateThread.start();
            componentQueryUpdateThreadMap.put(component.getId(), queryUpdateThread);

            // enqueue a task to register a new context enricher associated to this component
            // -> this will be done in parallel for the different existing DIVIDE queries
            enqueueContextEnricherUpdaterTask(component);

            // check if context is available for component, and if so, enqueue first
            // query derivation before registering observers
            Model componentContext = divideComponentManager.
                    getContextAssociatedToComponent(component.getId());
            if (componentContext == null) {
                LOGGER.info("No context available yet for component '{}' " +
                        "=> no query derivation enqueued yet", component.getId());
            } else if (componentContext.isEmpty()) {
                LOGGER.info("Available context for component '{}' is empty " +
                        "=> no query derivation enqueued yet", component.getId());
            } else {
                LOGGER.info("Context for component '{}' is available and non-empty " +
                        "=> first query derivation enqueued", component.getId());
                enqueueGeneralDivideQueryDerivationTask(component, new Context(componentContext));
            }

            // register component as observer for all its context IRIs
            component.getContextIris().forEach(
                    s -> divideComponentManager.addContextIriObserver(s, component));
        }

        return component;
    }

    @Override
    public void unregisterComponent(String id,
                                    boolean unregisterQueries) throws DivideNotInitializedException {
        LOGGER.info("Unregistering DIVIDE component with ID {}...", id);

        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        IComponent removed = divideComponentManager.unregisterComponent(id);

        // handle query update queue & thread if component ID exists and
        // is actually removed
        if (removed != null) {
            // no longer keep track of query update queue
            componentQueryUpdateQueueMap.remove(id);

            // interrupt the query update thread but still keep track of it so that
            // it can be observed that this thread was interrupted
            LOGGER.info("Interrupting query update thread of component {} because " +
                    "it is being removed", id);
            Thread queryUpdateThread = componentQueryUpdateThreadMap.get(id);
            queryUpdateThread.interrupt();

            // also interrupt the RSP engine status update thread
            if (pauseRspEngineStreamsOnContextChanges) {
                removed.getRspEngineHandler().stopRspEngineStreamsUpdates();
            }

            // if specified, remove all queries registered on the RSP engine
            // of this component by this DIVIDE engine
            // (interrupting the query update thread will ensure no new
            //  registrations or unregistrations take place in this thread)
            if (unregisterQueries) {
                removed.getRspEngineHandler().unregisterAllQueries();
            }
        }
    }

    @Override
    public Collection<IComponent> getRegisteredComponents() throws DivideNotInitializedException {
        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        return divideComponentManager.getRegisteredComponents();
    }

    @Override
    public IComponent getRegisteredComponentById(String id) throws DivideNotInitializedException {
        if (!initialized) {
            throw new DivideNotInitializedException();
        }

        return divideComponentManager.getRegisteredComponentById(id);
    }

    @Override
    public IDivideQueryParser getQueryParser() {
        return DivideQueryParserFactory.getInstance(
                processUnmappedVariableMatchesInParser,
                validateUnboundVariablesInRspQlQueryBodyInParser);
    }

    synchronized DivideOntology getDivideOntology() {
        return divideOntology;
    }

    /**
     * Preprocesses the sensor query rule of a new DIVIDE query.
     * For this preprocessing, the list of input variables in the consequence of the
     * rule is retrieved, parsed, checked for validity, and modified. The modifying
     * part consists of updating the order in which the input variables occur in the
     * list: if any input variable contains another one, the longer one should be
     * present first in the list, to avoid later substitution errors during the query
     * substitution process.
     *
     * @param sensorQueryRule sensor query rule to be preprocessed
     * @return preprocessed sensor query rule
     * @throws DivideInvalidInputException if definition of input variables in sensor
     *                                     query rule is invalid
     */
    private String preprocessSensorQueryRule(String sensorQueryRule)
            throws DivideInvalidInputException {
        Matcher m1 = INPUT_VARIABLE_LIST_PATTERN.matcher(sensorQueryRule);
        if (m1.find()) {
            Matcher m2 = INPUT_VARIABLE_DEFINITION_PATTERN.matcher(m1.group());
            Map<String, String> inputVariablesMap = new HashMap<>();
            while(m2.find()) {
                Matcher m3 = INPUT_VARIABLE_NAME_PATTERN.matcher(m2.group());
                if (m3.find()) {
                    inputVariablesMap.put(m3.group(1), m2.group());
                } else {
                    throw new DivideInvalidInputException(
                            "Sensor query rule of DIVIDE query does not " +
                            "contain a valid definition of the DIVIDE input variables");
                }
            }

            // sort input variable names occurring in list
            // -> construct new RDF list of lists (for input variables) based on sorted names
            String sortedInputVariables = inputVariablesMap.keySet()
                    .stream()
                    .sorted((s1, s2) -> s1.contains(s2) ?
                            (s1.equals(s2) ? 0 : -1) :
                            (s2.contains(s1) ? 1 : s1.compareTo(s2)))
                    .map(inputVariablesMap::get)
                    .collect(Collectors.joining(" "));
            String replacement = String.format("%s (%s)", m1.group(1), sortedInputVariables);

            return sensorQueryRule.replaceFirst(Pattern.quote(m1.group()), replacement);

        } else {
            throw new DivideInvalidInputException("Sensor query rule of DIVIDE query does not " +
                    "contain a valid definition of the DIVIDE input variables");
        }
    }

    /**
     * Adds a task to this component's queue to update the RSP queries for
     * this {@link IComponent}, with the specified context as input for the
     * query derivation.
     * This method will be called by the {@link DivideComponentManager} when
     * knowledge base changes to the context relevant for the given component
     * are observed.
     *
     * @param component {@link IComponent} for which the RSP queries should be updated
     * @param context context model to use as input for the query derivation, i.e.,
     *                the relevant context of the context IRIs associated to the given
     *                {@link IComponent} instance
     */
    void enqueueGeneralDivideQueryDerivationTask(IComponent component, Context context) {
        try {
            LOGGER.info("Enqueueing general DIVIDE query derivation task for component " +
                            "with ID '{}' and context ID '{}'",
                    component.getId(), context.getId());

            // retrieve component's query update request queue
            LinkedBlockingQueue<IDivideQueryUpdateTask> queue =
                    componentQueryUpdateQueueMap.get(component.getId());

            // if there is still any update task waiting in the queue, it can be
            // removed since the context has again been updated meanwhile
            // -> for the same tasks as these: it would not make sense to first
            //    do the update with the old context and then after that with the
            //    new context; better immediately do it with the new context)
            // -> for a task to unregister all queries associated to a removed
            //    DIVIDE query: since the new query derivation will no longer do
            //    the query derivation for this removed DIVIDE query, an update
            //    of the queries after the derivation will automatically result in
            //    the removal of all queries associated to this removed DIVIDE
            //    query (since no associated queries will end up in the list of
            //    new queries)
            // -> for a task to register new queries associated to a new DIVIDE
            //    query: since the new query derivation task will involve the query
            //    derivation for all registered DIVIDE queries, it will automatically
            //    also include the derivation of this new DIVIDE query
            queue.clear();

            // enqueue query update request with newest context in the component's queue
            queue.put(new GeneralDivideQueryDerivationTask(component, context));

            // restart query update thread if needed
            restartQueryUpdateThreadIfNeeded(component, queue);

        } catch (InterruptedException ignored) {
            LOGGER.error(LogConstants.UNKNOWN_ERROR_MARKER,
                    "Enqueueing general DIVIDE query derivation task for component with ID '{}'" +
                            "and context ID '{}' resulted in unexpected InterruptedException",
                    component.getId(), context.getId());

            // retry if interrupted while waiting (but the queue is not bounded
            // so normally the queue put operation should not block)
            enqueueGeneralDivideQueryDerivationTask(component, context);
        }
    }

    /**
     * Adds a task to this component's queue to update the RSP queries associated
     * to the given {@link IDivideQuery} for this {@link IComponent}, with the
     * specified context as input for the query derivation.
     * This method will be called upon the registration of a new DIVIDE query.
     *
     * @param component {@link IComponent} for which the RSP queries should be updated
     * @param context context model to use as input for the query derivation, i.e.,
     *                the relevant context of the context IRIs associated to the given
     *                {@link IComponent} instance
     * @param divideQuery DIVIDE query for which the query derivation task should
     *                    be enqueued
     */
    void enqueueSpecificDivideQueryDerivationTask(IComponent component,
                                                  Context context,
                                                  IDivideQuery divideQuery) {
        try {
            LOGGER.info("Enqueueing specific DIVIDE query derivation task for DIVIDE " +
                            "query '{}' for component " +
                            "with ID '{}' and context ID '{}'",
                    divideQuery.getName(), component.getId(), context.getId());

            // retrieve component's query update request queue
            LinkedBlockingQueue<IDivideQueryUpdateTask> queue =
                    componentQueryUpdateQueueMap.get(component.getId());

            // enqueue query update request with newest context in the component's queue
            queue.put(new SpecificDivideQueryDerivationTask(
                    component, context, divideQuery));

            // restart query update thread if needed
            restartQueryUpdateThreadIfNeeded(component, queue);

        } catch (InterruptedException ignored) {
            LOGGER.error(LogConstants.UNKNOWN_ERROR_MARKER,
                    "Enqueueing specific DIVIDE query derivation task for DIVIDE query '{}'," +
                            "component with ID '{}' and context ID '{}' resulted " +
                            "in unexpected InterruptedException",
                    divideQuery.getName(), component.getId(), context.getId());

            // retry if interrupted while waiting (but the queue is not bounded
            // so normally the queue put operation should not block)
            enqueueSpecificDivideQueryDerivationTask(component, context, divideQuery);
        }
    }

    /**
     * Adds a task to this component's queue to unregister the RSP queries for
     * this {@link IComponent} that are currently registered via the DIVIDE query
     * derivation of the specified DIVIDE query.
     * This method will be called by this engine when a DIVIDE query is unregistered
     * from the DIVIDE engine.
     *
     * @param component {@link IComponent} for which the RSP queries should be unregistered
     * @param divideQuery DIVIDE query of which the associated RSP engine queries need to be
     *                    unregistered from the wrapped RSP engine
     */
    private void enqueueDivideQueryRemovalHandlingTask(IComponent component,
                                                       IDivideQuery divideQuery,
                                                       boolean unregisterQueries) {
        try {
            LOGGER.info("Enqueueing DIVIDE query removal handling task for component " +
                            "with ID '{}' and DIVIDE query '{}'",
                    component.getId(), divideQuery.getName());

            // retrieve component's query update request queue
            LinkedBlockingQueue<IDivideQueryUpdateTask> queue =
                    componentQueryUpdateQueueMap.get(component.getId());

            // enqueue removal handling task
            // IMPORTANT: the queue is not cleared in this case, since this involves
            //            no query derivation of the remaining DIVIDE queries which
            //            is therefore a task that cannot be ignored
            queue.put(new DivideQueryRemovalHandlingTask(
                    component, divideQuery, unregisterQueries));

            // restart query update thread if needed
            restartQueryUpdateThreadIfNeeded(component, queue);

        } catch (InterruptedException ignored) {
            LOGGER.error(LogConstants.UNKNOWN_ERROR_MARKER,
                    "Enqueueing DIVIDE query removal handling task for component with ID '{}' " +
                            "and DIVIDE query '{}' resulted in unexpected InterruptedException",
                    component.getId(), divideQuery.getName());

            // retry if interrupted while waiting (but the queue is not bounded
            // so normally the queue put operation should not block)
            enqueueDivideQueryRemovalHandlingTask(component, divideQuery, unregisterQueries);
        }
    }

    private void enqueueContextEnricherUpdaterTask(IComponent component,
                                                   IDivideQuery divideQuery) {
        try {
            LOGGER.info("Enqueueing task to update context enrichers for DIVIDE " +
                            "query '{}' for component with ID '{}'",
                    divideQuery.getName(), component.getId());

            // retrieve component's query update request queue
            LinkedBlockingQueue<IDivideQueryUpdateTask> queue =
                    componentQueryUpdateQueueMap.get(component.getId());

            // enqueue query update request with newest context in the component's queue
            queue.put(new ContextEnricherUpdaterTask(component, divideQuery));

            // restart query update thread if needed
            restartQueryUpdateThreadIfNeeded(component, queue);

        } catch (InterruptedException ignored) {
            LOGGER.error(LogConstants.UNKNOWN_ERROR_MARKER,
                    "Enqueueing task to update context enrichers for DIVIDE query '{}' for " +
                            "component with ID '{}' resulted in unexpected InterruptedException",
                    divideQuery.getName(), component.getId());

            // retry if interrupted while waiting (but the queue is not bounded
            // so normally the queue put operation should not block)
            enqueueContextEnricherUpdaterTask(component, divideQuery);
        }
    }

    private void enqueueContextEnricherUpdaterTask(IComponent component) {
        try {
            LOGGER.info("Enqueueing task to update context enrichers for all DIVIDE queries " +
                            "on component with ID '{}'", component.getId());

            // retrieve component's query update request queue
            LinkedBlockingQueue<IDivideQueryUpdateTask> queue =
                    componentQueryUpdateQueueMap.get(component.getId());

            // enqueue query update request with newest context in the component's queue
            queue.put(new ContextEnricherUpdaterTask(component));

            // restart query update thread if needed
            restartQueryUpdateThreadIfNeeded(component, queue);

        } catch (InterruptedException ignored) {
            LOGGER.error(LogConstants.UNKNOWN_ERROR_MARKER,
                    "Enqueueing task to update context enrichers for all DIVIDE queries on " +
                            "component with ID '{}' resulted in unexpected InterruptedException",
                    component.getId());

            // retry if interrupted while waiting (but the queue is not bounded
            // so normally the queue put operation should not block)
            enqueueContextEnricherUpdaterTask(component);
        }
    }

    private void restartQueryUpdateThreadIfNeeded(IComponent component,
                                                  LinkedBlockingQueue<IDivideQueryUpdateTask> queue) {
        // check if thread that is processing query updates is interrupted
        // (in that case it will have been removed from the query update thread map),
        // and if so, create & start new thread for this
        Thread queryUpdateThread =
                componentQueryUpdateThreadMap.get(component.getId());
        if (queryUpdateThread == null) {
            LOGGER.info("Query update thread for component with ID '{}' has been " +
                            "interrupted, so a new thread is started",
                    component.getId());

            Thread newQueryUpdateThread = new Thread(() ->
                    processRspQueryUpdateQueue(component, queue));
            newQueryUpdateThread.start();
            componentQueryUpdateThreadMap.put(component.getId(), newQueryUpdateThread);
        }
    }

    private void processRspQueryUpdateQueue(IComponent component,
                                            LinkedBlockingQueue<IDivideQueryUpdateTask> queryUpdateQueue) {
        try {
            boolean interrupted = false;
            while (!interrupted) {
                // retrieve the updated context from the queue - blocks if the
                // queue is empty until an item again enters the queue
                IDivideQueryUpdateTask queryUpdateTask = queryUpdateQueue.take();

                // launch the query derivation for the given component & context
                interrupted = queryUpdateTask.execute();
            }

            // thread is interrupted explicitly by the system, probably because
            // the component is unregistered
            LOGGER.info("Query update thread for component '{}' is found interrupted after query" +
                    " update, so is stopping with the processing of the query update queue",
                    component.getId());

        } catch (InterruptedException e) {
            LOGGER.info("Query update thread for component '{}' is interrupted while waiting," +
                    " so is stopping with the processing of the query update queue",
                    component.getId());
        }

        // remove thread from query update thread map so that the engine
        // knows a new thread should be started upon arrival of a new
        // query update request
        // (after exiting this method, the thread status will become TERMINATED)
        componentQueryUpdateThreadMap.remove(component.getId());
    }

    private class GeneralDivideQueryDerivationTask implements IDivideQueryUpdateTask {

        private final Logger LOGGER = LoggerFactory.getLogger(
                GeneralDivideQueryDerivationTask.class.getName());

        private final IComponent component;
        private final Context context;

        GeneralDivideQueryDerivationTask(IComponent component, Context context) {
            this.component = component;
            this.context = context;
        }

        @Override
        public boolean execute() {
            LOGGER.info("Preparing DIVIDE query derivation for component with ID '{}' " +
                            "and context '{}' in RSP query update thread",
                    component.getId(), context.getId());

            // retrieve list of queries
            Collection<IDivideQuery> divideQueries;
            synchronized (divideQueryMap) {
                divideQueries = divideQueryMap.values();
            }

            // stop if list of queries is empty
            if (divideQueries.isEmpty()) {
                LOGGER.info("DIVIDE query derivation for component with ID '{}' and context '{}': " +
                                "no DIVIDE queries registered, so finishing task",
                        component.getId(), context.getId());
                return Thread.currentThread().isInterrupted();
            }

            // run the query derivation scripts in parallel for every DIVIDE query,
            // each on a dedicated thread in the worker thread pool
            CountDownLatch latch = new CountDownLatch(divideQueries.size());
            DivideOntology ontology = getDivideOntology();
            for (IDivideQuery divideQuery : divideQueries) {
                workerThreadPool.submit(new SingleQueryDeriver(
                        divideQuery, context, component,
                        divideQueryDeriver, ontology, latch));
            }

            // keep track of whether the thread gets interrupted while waiting for
            // the other threads to finish
            boolean interruptedWhileWaiting = false;

            // wait until the query derivation threads have all finished
            boolean queryDerivationThreadsFinished = false;
            while (!queryDerivationThreadsFinished) {
                try {
                    LOGGER.info("DIVIDE query derivation for component with ID '{}' and context '{}': " +
                                    "waiting for other threads to finish the individual query derivations" +
                                    " for the different DIVIDE queries",
                            component.getId(), context.getId());

                    // wait for the latch to be decremented by the query derivation threads
                    latch.await();

                    // if the previous call returns, this means that all threads have
                    // finished (since they all count down the latch when finished)
                    queryDerivationThreadsFinished = true;

                } catch (InterruptedException e) {
                    // interrupts of this thread should be ignored, since it is really
                    // required to await the latch being count down to zero
                    // (and only handle interrupt requests at the end of this method)
                    LOGGER.info("DIVIDE query derivation for component with ID '{}' and context '{}': " +
                                    "query update thread interrupted while waiting for other threads",
                            component.getId(), context.getId());

                    // it is however important to remember that this interruption happened
                    // while waiting
                    interruptedWhileWaiting = true;
                }
            }

            // check if thread has been interrupted up to this point
            // -> if so, no query registration update should take place
            //    (in normal circumstances this only happens if the component is
            //     unregistered from the engine)
            if (interruptedWhileWaiting || Thread.currentThread().isInterrupted()) {
                LOGGER.info("DIVIDE query derivation for component with ID '{}' and context '{}': " +
                                "not registering queries since query update thread has been interrupted",
                        component.getId(), context.getId());

                // clearing registration schedule since no queries will be registered anymore
                component.getRspEngineHandler().clearRegistrationSchedule();

                // check if there already is a new general DIVIDE query derivation task
                // in the queue at this point, AND the RSP engine streams are paused
                // on context changes
                // -> if yes, no query registration update should take place (since the
                //    RSP engine streams are paused, and it only makes sense to update
                //    them after the last general DIVIDE query derivation task in the
                //    queue has completed (since they are derived from the most recent
                //    up-to-date context)
            } else if (pauseRspEngineStreamsOnContextChanges &&
                    componentQueryUpdateQueueMap.get(component.getId()).stream().anyMatch(
                    queryUpdateTask -> queryUpdateTask instanceof GeneralDivideQueryDerivationTask)) {
                LOGGER.info("DIVIDE query derivation for component with ID '{}' and context '{}': " +
                                "not registering queries since query update queue contains new " +
                                "general DIVIDE query derivation task",
                        component.getId(), context.getId());

                // clearing registration schedule since no queries will be registered anymore
                component.getRspEngineHandler().clearRegistrationSchedule();

            } else {
                // update query registration at actual RSP engine
                component.getRspEngineHandler().updateRegistration();
            }

            // in any case, it is still important to try restarting the engine
            // (if being interrupted explicitly because the component is being
            //  removed, then all updates will be stopped explicitly anyway)
            // -> and if no restart is allowed because of new pause requests
            if (pauseRspEngineStreamsOnContextChanges) {
                component.getRspEngineHandler().restartRspEngineStreams();
            }

            LOGGER.info("Finished DIVIDE query derivation for component with ID '{}' and context '{}'",
                    component.getId(), context.getId());

            return interruptedWhileWaiting || Thread.currentThread().isInterrupted();
        }
    }

    private class SpecificDivideQueryDerivationTask implements IDivideQueryUpdateTask {

        private final Logger LOGGER = LoggerFactory.getLogger(
                SpecificDivideQueryDerivationTask.class.getName());

        private final IComponent component;
        private final Context context;
        private final IDivideQuery divideQuery;

        SpecificDivideQueryDerivationTask(IComponent component,
                                          Context context,
                                          IDivideQuery divideQuery) {
            this.component = component;
            this.context = context;
            this.divideQuery = divideQuery;
        }

        @Override
        public boolean execute() {
            LOGGER.info("Preparing specific DIVIDE query derivation for DIVIDE query '{}', " +
                            "for component with ID '{}' " +
                            "and context '{}' in RSP query update thread",
                    divideQuery.getName(), component.getId(), context.getId());

            // run the query derivation script in for the given DIVIDE query,
            // on a dedicated thread in the worker thread pool
            CountDownLatch latch = new CountDownLatch(1);
            workerThreadPool.submit(new SingleQueryDeriver(
                    divideQuery, context, component,
                    divideQueryDeriver, getDivideOntology(), latch));

            // keep track of whether the thread gets interrupted while waiting for
            // the other threads to finish
            boolean interruptedWhileWaiting = false;

            // wait until the query derivation threads have all finished
            boolean queryDerivationThreadsFinished = false;
            while (!queryDerivationThreadsFinished) {
                try {
                    LOGGER.info("Specific DIVIDE query derivation for DIVIDE query '{}', " +
                                    "for component with ID '{}' and context '{}': " +
                                    "waiting for other thread to finish the individual query derivation",
                            divideQuery.getName(), component.getId(), context.getId());

                    // wait for the latch to be decremented by the the query derivation threads
                    latch.await();

                    // if the previous call returns, this means that the thread has finished
                    queryDerivationThreadsFinished = true;

                } catch (InterruptedException e) {
                    // interrupts of this thread should be ignored, since it is really
                    // required to await the latch being count down to zero
                    // (and only handle interrupt requests at the end of this method)
                    LOGGER.info("Specific DIVIDE query derivation for DIVIDE query '{}', " +
                                    "for component with ID '{}' and context '{}': " +
                                    "query update thread interrupted while waiting for other threads",
                            divideQuery.getName(), component.getId(), context.getId());

                    // it is however important to remember that this interruption happened
                    // while waiting
                    interruptedWhileWaiting = true;
                }
            }

            if (!interruptedWhileWaiting && !Thread.currentThread().isInterrupted()) {
                // update query registration at actual RSP engine for this DIVIDE query
                component.getRspEngineHandler().updateRegistration(divideQuery);
            } else {
                LOGGER.info("Specific DIVIDE query derivation for DIVIDE query '{}', " +
                                "for component with ID '{}' and context '{}': " +
                                "not registering queries since query update thread has been interrupted",
                        divideQuery.getName(), component.getId(), context.getId());

                // clearing registration schedule since no queries will be registered anymore
                component.getRspEngineHandler().clearRegistrationSchedule(divideQuery);
            }

            LOGGER.info("Finished DIVIDE query derivation for component with ID '{}' and context '{}'",
                    component.getId(), context.getId());

            return interruptedWhileWaiting || Thread.currentThread().isInterrupted();
        }
    }

    private static class DivideQueryRemovalHandlingTask implements IDivideQueryUpdateTask {

        private static final Logger LOGGER = LoggerFactory.getLogger(
                DivideQueryRemovalHandlingTask.class.getName());

        private final IComponent component;
        private final IDivideQuery divideQuery;
        private final boolean unregisterQueries;

        DivideQueryRemovalHandlingTask(IComponent component,
                                       IDivideQuery divideQuery,
                                       boolean unregisterQueries) {
            this.component = component;
            this.divideQuery = divideQuery;
            this.unregisterQueries = unregisterQueries;
        }

        @Override
        public boolean execute() {
            LOGGER.info("Handling the removal of DIVIDE query '{}' at component with ID '{}':" +
                            "unregistering context enrichers{}",
                    divideQuery.getName(), component.getId(),
                    unregisterQueries ? " and starting the unregistering of all queries" : "");

            if (!Thread.currentThread().isInterrupted()) {
                // unregister context enricher for the given component and DIVIDE query
                component.unregisterContextEnricher(divideQuery);

                if (unregisterQueries) {
                    // update query registration at actual RSP engine
                    component.getRspEngineHandler().
                            unregisterAllQueriesOriginatingFromDivideQuery(divideQuery);
                }
            } else {
                LOGGER.info("Unregistering of all queries at {} associated to " +
                                "removed DIVIDE query {} has been interrupted",
                        component.getId(), divideQuery.getName());
            }

            LOGGER.info("Finished unregistering of all queries at {} associated to " +
                            "removed DIVIDE query {}",
                    component.getId(), divideQuery.getName());

            return Thread.currentThread().isInterrupted();
        }

    }

    private class ContextEnricherUpdaterTask implements IDivideQueryUpdateTask {

        private final Logger LOGGER = LoggerFactory.getLogger(
                ContextEnricherUpdaterTask.class.getName());

        private final IComponent component;
        private final Collection<IDivideQuery> divideQueries;

        ContextEnricherUpdaterTask(IComponent component,
                                   IDivideQuery divideQuery) {
            this.component = component;
            this.divideQueries = Collections.singletonList(divideQuery);
        }

        ContextEnricherUpdaterTask(IComponent component) {
            this.component = component;
            this.divideQueries = new ArrayList<>();
        }

        @Override
        public boolean execute() {
            // retrieve list of all DIVIDE queries if no set of queries is specified for this task
            if (divideQueries.isEmpty()) {
                synchronized (divideQueryMap) {
                    divideQueries.addAll(divideQueryMap.values());
                }
            }

            // stop if list of queries is empty
            if (divideQueries.isEmpty()) {
                LOGGER.info("Task to update context enrichers for component with ID '{}': " +
                                "stopped, since no DIVIDE queries are registered",
                        component.getId());
                return Thread.currentThread().isInterrupted();
            }

            LOGGER.info("Starting task to update context enrichers for component with ID '{}' " +
                            "and following queries: {}",
                    component.getId(),
                    divideQueries.stream().map(IDivideQuery::getName).collect(Collectors.joining(", ")));
            long start = System.currentTimeMillis();

            // create the context enricher for each given DIVIDE query,
            // on a dedicated thread in the worker thread pool
            CountDownLatch latch = new CountDownLatch(divideQueries.size());
            for (IDivideQuery divideQuery : divideQueries) {
                workerThreadPool.submit(new SingleContextEnricherUpdater(
                        component,
                        divideQuery,
                        getDivideOntology(),
                        latch));
            }

            // keep track of whether the thread gets interrupted while waiting for
            // the other threads to finish
            boolean interruptedWhileWaiting = false;

            // wait until the context enricher creation threads have all finished
            boolean threadsFinished = false;
            while (!threadsFinished) {
                try {
                    LOGGER.info("Waiting for threads to finish parallel updating of context enricher " +
                                    "for component with ID '{}' for {} DIVIDE queries",
                            component.getId(), divideQueries.size());

                    // wait for the latch to be decremented by the different threads
                    // -> after this method call completes, all parallel tasks are finished
                    latch.await();

                    // if the previous call returns, this means that the thread has finished
                    threadsFinished = true;

                } catch (InterruptedException e) {
                    // interrupts of this thread should be ignored, since it is really
                    // required to await the latch being count down to zero
                    // (and only handle interrupt requests at the end of this method)
                    LOGGER.info("Parallel updating of context enricher for component with ID '{}': " +
                                    "query update thread interrupted while waiting for other threads",
                            component.getId());

                    // it is however important to remember that this interruption happened
                    // while waiting
                    interruptedWhileWaiting = true;
                }
            }

            LOGGER.info("Finished updating context enrichers for component with ID '{}' and " +
                            "queries {} in {} ms",
                    component.getId(),
                    divideQueries.stream().map(IDivideQuery::getName).collect(Collectors.toList()),
                    System.currentTimeMillis() - start);

            return interruptedWhileWaiting || Thread.currentThread().isInterrupted();
        }
    }

}
